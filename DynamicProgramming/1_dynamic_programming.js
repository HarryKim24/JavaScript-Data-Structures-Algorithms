// 다이나믹 프로그래밍

/*
  메모리를 더 사용하여 시간 복잡도를 개선할 때 주로 사용
  시간 복잡도가 비효율적인 알고리즘이 있을 때 부분 문제의 반복이 발생하는 경우 적용
  다이나믹 프로그래밍 문제를 해결하기 위해 점화식을 찾는 것이 핵심
*/


// 다이나믹 프로그래밍 사용 조건

/*
  1. 최적 부분 구조(optimal substructure) -> 점화식 형태로 표현 가능
    - 큰 문제를 유사한 형태의 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아 큰 문제를 해결
  2. 반복되는 부분 문제(overlapping sub-problem)
    - 동일한 작은 문제를 반복적으로 해결
*/


// 대표적인 예시

/*
  피보나치 수열: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...]
  점화식: 인접한 항으로 현재 값을 결정하는 관계식
  -> 일반적으로 최적 부분 구조를 만족
  
  피보나치 수열의 점화식: An = An-1 + An-2 (A1 = 1, A2 = 1)
*/


// 점화식의 구성 요소

/*
  1. 초기항
  2. 인접한 항과의 관계
    - 점화식은 [재귀 함수]로 표현
    - 재귀 함수는[종료 조건]이 필요, 이것이 점화식의 초기항과 같은 역할 수행

  피보나치 함수(Fibonacci Function)을 재귀함수로 표현
  function fibo(x) {
    if (x == 1 || x == 2) return 1;
    return fibo(x - 1) + fibo(x - 2);
  }
  console.log(fibo(4));
*/


// 다이나믹 프로그래밍의 일반 형태

/*
  피보나치 수열의 점화식을 그대로 재귀 함수로 구현하면 발생하는 문제
    -> 중복되는 부분 문제가 발생 (이미 구한 값을 불필요하게 반복 계산)
  다이나믹 프로그래밍이 이 문제를 해결 가능
  
  function dp() {
    1. 종료 조건
    2. 이미 해결한 문제라면, 정답을 그대로 반환
    3. 점화식에 따라 정답 계산
  }
*/


// 다이나믹 프로그래밍 문제 해결 과정

/*
  1. 문제 이해
  2. 점화식 찾아내기 -> 가장 핵심적인 부분
  3. 구현 방식(상향식/하향식) 결정
  4. 점화식을 실제 코드로 구현
*/


// 다이나믹 프로그래밍 문제 접근 방법

/*
  1. 상향식: 반복문을 이용해 초기 항부터 계산
  2. 하향식: 재귀 함수로 큰 항을 구하기 위해 작은(이전) 항을 호출하는 방식
    -> 이미 구한 함수 값을 담는 테이블을 주로 DP 테이블이라고 한다.
*/


// 피보나치 수열(하향식)

d = new Array(100).fill(0) // 한 번 계산된 결과를 메모이제이션 하기 위한 리트스 초기화

// 피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
function fibo(x) {
  if (x == 1 || x == 2) return 1; // 종료 조건(1 혹은 2일 때 1을 반환)

  if (d[x] != 0) return d[x]; // 이미 계산한 적이 있으면 그대로 반환
  
  d[x] = fibo(x - 1) + fibo(x - 2); // 아직 계산하지 않았으면 점화식에 따라 피보나치 결과 반환
  return d[x];
}

console.log(fibo(99));


// 피보나치 수열(상향식)

d = new Array(100).fill(0); // 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화

// 첫 번째, 두 번째 피보나치 수는 1
d[1] = 1;
d[2] = 1;
n = 99;

// 피보나치 함수를 반복문으로 구현
for (let i = 3; i <= n; i++) {
  d[i] = d[i - 1] + d[i - 2];
} 

console.log(d[n]);