// 백트래킹 알고리즘

/*
  일반적으로 그래프/트리의 모든 원소를 완전 탐색하기 위한 목적으로 사용
  추후의 DFS와의 차이점
  1) DFS는 일반적으로 완전 탐색 목적으로, 재귀 함수를 이용해 구현
  2) 백트래킹도 재귀 함수를 이용해 구현하는 것이 일반적이지만,
    단순히 완전 탐색하는 것이 아니라 조건에 따라 유망한 노드로 이동.
*/


// 그래프 표현 방식

/*
  그래프를 표현하는 2가지 방식

  1) 인접 행렬
  [
    [0, 1, 0, 0],
    [1, 0, 1, 1],
    [0, 1, 0, 1],
    [0, 1, 1, 0]
  ]

  2) 인접 리스트
  1 [2]
  2 [1, 3, 4]
  3 [2, 4]
  4 [2 ,3]
*/


// N-Queen 문제

/*
  N X M 체스 보드 위에 퀸 N개가 서로 공격할 수 없게 놓는 문제

  N = 8일 경우
  64개의 위치에 8개의 퀸을 설치하는 모든 조합의 수는 Combination(64, 8)
  각 퀸이 서로 공격이 가능한지 검사하는 방식을 사용하면 경우의 수가 매우 커짐

  [문제 해결 아이디어]
  완전 탐색을 하더라도 유망한 경우에 대해서만 탐색을 진행

  1) N개의 퀸을 놓기 위해서는 각 행마다 1개씩의 퀸을 놓아야 함
  2) 하나의 퀸 A가 이미 존재하는 상태에서, 
    다른 퀸 B는 퀸 A의 상하좌우 및 대각선 위치가 아닌 위치에 놓아야 함
    2-1) 같은 행에 있는지 체크: x1 == x2 / 같은 열에 있는지 체크: y1 == y2
    2-2) 같은 대각선에 있는지 체크: abs(x1, x2) == abs(y1, y2)
  3) 트리 구조로 표현
*/


// 백트래킹을 진행할 때, 경우의 수를 최대한 줄이는 방법

/*
  방법: 이전까지 놓았던 퀸들과 상충되지 않는 조건을 만족하는 위치에 대해서만 재귀 함수 호출
  1) 재귀 함수를 통해 모든 경우의 수를 다 찾은 뒤에, 각 경우마다 가능한지 검사
  2) 유망한 경우에 대해서만 재귀 함수를 호출
*/


// 백트래킹의 기본 형태
function recursive() {
  if ('종료 조건 만족') {
    '처리';
  }
  for ('자식 노드'; '하나씩'; '확인') {
    if ('임의 조건 만족') {
      '자식 노드 방문 처리';
      '재귀 함수 호출';
      '자식 노드 방문 처리 해제';
    }
  }
}


// N-Queen 해결 코드 예시

let n = 8; // 전체 맵의 크기
let queens = []; // 현재 체스판에 놓인 퀸의 위치 정보들

function possible(x, y) { // (x, y) 위치에 퀸을 놓을 수 있는지 확인
  for (let [a, b] of queens) { // 이전까지 놓았던 퀸의 위치를 하나씩 확인
    if (a == x || b == y) return false; // 행이나 열이 같다면 불가
    if (Math.abs(a - x) == Math.abs(b - y)) return false; // 대각선에 위치하면 불가
  }
  return true;
}

let cnt = 0;

function dfs(row) {
  if (row == n) cnt += 1; // 퀸을 N개 배치할 수 있는 경우 카운트
  for (let i = 0; i < n; i++) { // 현재 행에 존재하는 열을 하나씩 확인
    if (!possible(row, i)) continue; // 현재 위치에 놓을 수 없다면 무시
    queens.push([row, i]); // 현재 위치에 퀸 배치
    dfs(row + 1); // 재귀 함수 호출
    queens.pop(); // 현재 위치에서 퀸 제거
  }
}
dfs(0);
console.log(cnt);